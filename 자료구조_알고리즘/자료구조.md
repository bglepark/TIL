# 자료구조

- 내용 

  - 자료구조 기본 개념
  - 기본 알고리즘
  - 파이썬 프로그래밍



## 선형 자료 구조

> 데이터를 한 줄로 순차적으로 표현한 형태 --> 선형 리스트 , 연결 리스트 , 스택 , 큐



### 1. 선형 리스트

- 데이터를 일정한 순서로 나열한 자료 구조
- 순차 리스트(Ordered List)라고도 함
- 선형 리스트는 입력 순서대로 저장하는 데이터에 해당한다.

- 배열 형태이며 추가/삽입/삭제가 가능하다.
- 추가/삽입/삭제에 많은 작업이 필요하므로 오버헤드 발생
- 공간적 및 논리적으로 배열이 형성되어 있다. -> 접근 속도가 빠르다.
  - ex) 시계열 데이터



> 카톡 온 순서대로 데이터를 선형 리스트로 표현

```python
## 함수 선언부
def add_data(friend): # katok 배열에 friend 추가
    katok.append(None) #배열 맨 뒤에 빈칸 추가
    kLen = len(katok)
    katok[kLen-1] = friend # (배열 길이 - 1) 위치에 데이터 삽입
    
def insert_data(position , friend): #katok 배열 내 원하는 position에 friend 추가
    katok.append(None)
    kLen = len(katok) #position에 friend가 들어가도록 배열을 한칸씩 이동해줘야함
    for i in range(kLen-1 , position , -1):
   		katok[i] = katok[i-1]
    	katok[i-1] = None #옮긴 변수는 None으로 빈칸으로 만들어줌
    katok[position] = friend
    
def delete_data(position):
    katok[position] = None #빈칸으로 처리
    kLen = len(katok)
    for i in range(position+1, kLen , 1): #삭제한 position 뒤부터니까 position+1
        katok[i-1]=katok[i]
        katok[i]=None
    del(katok[kLen-1]) #칸 자체를 삭제
    
## 전역 변수부
katok = [] 
select = -1

## 메인 코드 부분
if __name__ =='__main__':

    while(select!=4):
        select = int(input('선택하세요(1:추가 , 2:삽입 , 3:삭제 , 4:종료) -->'))

        if select == 1:
            data= input("추가할 데이터 -->")
            add_data(data)
            print(katok)
        elif select ==2:
            pos = int(input('삽입할 위치 -->'))
            data = input('추가할 데이터 -->')
            insert_data(pos,data)
            print(katok)
        elif select ==3 :
            pos = int(input('삭제할 위치 -->'))
            delete_data(pos)
            print(katok)
        elif select ==4:
            print(katok)
            exit
        else:
            print('1~4 중 하나를 입력하세요.')
            continue
```



### 2. 단순 연결 리스트

- 노드라고 표현
- 논리적으로는 붙어있지만 물리적으로는 떨어져 있다.
- 화살표로 표시된 연결(링크 , Link)을 따라가면 선형 리스트 순서와 같다.
- 해당 노드의 앞뒤 링크만 수정하면 되므로 오버헤드가 거의 발생하지 않는다.

```
노드는 데이터와 링크로 구성된 항목이다.
```



> 단순 연결 리스트를 통한 데이터 추가/삽입/삭제

```python
## 함수
class Node() :
    def __init__(self):
        self.data = None
        self.link = None


## 전역

## 메인
node1 = Node()
node1.data = 'A'

node2 = Node()
node2.data = 'B'
node1.link = node2 #node1의 link는 node를 가리킴

node3 = Node()
node3.data = 'C'
node2.link = node3

node4 = Node()
node4.data = 'D'
node3.link = node4

node5 = Node()
node5.data = 'E'
node4.link = node5

# 다른 예시
# print(node1.data , end= ' ')
# print(node1.link.data , end = ' ')
# print(node1.link.link.data , end = ' ')
# print(node1.link.link.link.data , end = ' ')
# print(node1.link.link.link.link.data , end = ' ')

# 중간에 데이터 삽입
newNode = Node()
newNode.data = '홍길동'
newNode.link = node2.link
node2.link = newNode

# 중간 데이터 삭제
node2.link = node3.link
del(node3)

# link가 None이면 출력 그만 , 계속 연결해서 출력하는 방법
current = node1
print(current.data , end= ' ')
while current.link != None:
    current = current.link # 계속 그 다음 노드로 이동
    print(current.data, end=' ')
```



>  단순 연결 리스트를 통한 데이터 추가/삽입/삭제 (함수 이용)

```python
## 함수
class Node() :
    def __init__(self):
        self.data = None
        self.link = None

def printNodes(start): #출력하는 함수
    current = start
    print(current.data , end = ' ')
    while current.link != None:
        current = current.link
        print(current.dat , end = ' ')
    print()

# head 변경 : 첫 번째 노드 삽입
def insertNode(findData , insertData):
    global memory , head , current , pre
    
    # 첫번째 노드 앞에 삽입할 경우
    if findData == head.data:
        node = Node()
        node.data = insertData
        node.link = head
        head = node
        return
    
    # 두번째 노드 이후 삽입 (중간 노드 삽입)
    current = head # 첫번째부터 변경시작을 위해 변수 선언
    while current.link != None:
        pre = current #current가 다음 link로 가기 전에 pre에 저장
        current = current.link
        if current.data == findData:
            node = Node()
            node.data = insertData
            node.link = current #node는 current에 연결
            pre.link = node #pre는 node에 연결
            return
        
    # findData가 없는 경우 맨 뒤에 삽입
    node = Node()
    node.data = insertData
    current.link = node
    return

# 노드 삭제하기
def deleteNode(deleteData):
    global memory , head , current , pre
    
    # 첫 노드 삭제 시
    if deleteData == head.data :
        current = head
        head = head.link #head 다음 변수를 head로 지정
        del(current)
        return
    
    # 두 번째 이후 노드 삭제 시
    current = head
    while current.link!=None:
        pre = current
        current = current.link
        if current.data == deleteData:
            pre.link = current.link
            del(current)
            return
        
# 노드 검색하기
def findNode(findData):
    global memory , head , current , pre
    current = head
    if current.data == findData:
        return current
    while current.link!=None:
        current = current.link
        if current.data == findData:
            return current
    return Node() # 못 찾았을 경우 빈 노드 return
        
    
## 전역
memory = []
head , current , pre = None , None , None , None 
dataArray = ['홍길동' , '이순신' , '사오정' , '손오공' , '강감찬']

## 메인
node = Node()
node.data = dataArray[0]
head = node # 첫 번째 변수를 head로 지정
memory.append(node) # 홍길동

for data in dataArray[1:] : # ['이순신' , '사오정' , '손오공' , '강감찬']
    pre = node
    node = Node() #새로운 node class를 생성하기 전에 pre 라는 변수에 저장
    node.data = data
    pre.link = node
    memory.append(node)
    

```





